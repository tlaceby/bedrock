// main.br

trait Error {
  fn error () -> String;
}

struct FooError {
  fn error () -> String {
    return "Error: Foo";
  }
}

struct CustomError {
  message: String;

  static fn new(message: String) -> Self {
    return Self { 
      message: message,
    };
  }

  fn error () -> String {
    return self.message;
  }
}

fn main () {
  let err1 = CustomError::new("Something went wrong");
  let err2 = FooError{};

  const errors = []Error{ err1, err2 };
  
  let e1 = errors[0]; // Error not CustomError
  let e2 = errors[1]; // Error not FooError

  // Comptime Helper Macro
  // let (numStr, err) = @String(45.21); // Converts to a String
  // let customErr = @Assert(CustomError, errors[1]); // casts away a type explicitly. No conversion is done
  // customErr.message = "This should work after the cast";
} 
// main.br

trait Error {
  fn error () -> String;
}

struct FooError {
  fn error () -> String {
    return "Error: Foo";
  }
}

struct CustomError {
  message: String;

  static fn new(message: String) -> Self {
    return Self { 
      message: message,
    };
  }

  fn error () -> String {
    return self.message;
  }
}

fn main () {
  const errors = []Error{ 
    CustomError::new("Something went wrong"),
    FooError{} 
  };
  
  const e1 = errors[0];
  const e2 = errors[1];
  const message: String = e1.error() + e2.error();

  const numStr = @string(45.21); // Converts Data to a String
  const customErr = @assert(CustomError, errors[1]); // casts away a type explicitly. No conversion
  
  println(customErr.error());
} 
// main.br

trait Error {
  fn error () -> String;
}

struct FooError {
  fn error () -> String {
    return "Error: Foo";
  }
}

struct CustomError {
  message: String;

  static fn new(message: String) -> Self {
    return Self { 
      message: message,
    };
  }

  fn error () -> String {
    return self.message;
  }
}

fn main () {
  let err1 = CustomError::new("Something went wrong");
  let err2 = FooError{};

  const errors = []Error{ err1, err2 };
  
  let e1 = errors[0]; // Error not CustomError
  let e2 = errors[1]; // Error not FooError

  // Comptime Helper Macros
  let numStr = @string(45.21); // Converts Data to a String
  let customErr = @assert(CustomError, errors[1]); // casts away a type explicitly. No conversion
  
  println(customErr.error());
} 
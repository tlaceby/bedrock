import("std") as std;

type numericBinaryHandler = fn (Number, Number) -> Number;

enum Option<T> {
    Ok(T),
    None
}

enum Result<T, E> {
    Ok(T),
    Err(E)
}

struct Rect {
    width: Number,
    height: Number
}

impl Rect {
    fn area(self) -> Number {
        return self.width * self.height;
    }

    fn zero(self) -> Self {
        self.width = self.height = 0;
    }
}

fn even_only(num: Number) -> Option<Number> {
    if num % 2 == 0 {
        return Ok(num);
    }

    return None();
}

fn main () {
    let currentTime: Number = std::date::now();
    let platform: String = process::platform();
    let debugMode: String = process::debugMode();

    // Logging to stdout with string interpolation
    std::debug("Time={} | Platform={} | Mode={}", currentTime, platform, debugMode);

    // --- Working w/ Option<T> ---
    let num = std::rand::rand_int();
    match even_only(num) {
        Ok(_)  -> std::debug("Number is even {}", [num]);
        None() -> std::debug("Number is not even {}", [num]);
    };

    // Panics in event optional is empty
    let evenNum  = even_only(num).unwrap();
    // Using unwrap_or instead to give value in event option is empty
    let closestEvenNum = even_only(num).unwrap_or(num + 1);

   // --- Working w/ Result<T, E> ---
    let readResult: Result<String, std::fs::FileReadErr> = std::fs::read_to_string("test.txt");
    match readResult {
        Ok(contents) -> std::debug(contents);
        Err(err) -> {
            std::debug("Error occured during file reading. {} | {}", err.tag, err.message);
            process::exit(1);
            // or we could panic which would achieve the same result but with more stack tracing info
            panic("Error occured during file reading. {} | {}", err.tag, err.message);
        } 
    }

    // Unwrap also works with Result types
    let contents = readResult.unwrap();
    // Or we can also set a default value
    let contentsWithDefault = readResult.unwrap_or("Some content as default");
}